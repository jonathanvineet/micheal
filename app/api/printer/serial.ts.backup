/**
 * Core serial communication module for 3D printer (Marlin firmware)
 * Handles USB serial connection and G-code command execution
 * Falls back to mock mode if native bindings unavailable
 */

import { getSerialPortClasses } from "./server-serial";

// Printer serial configuration
const SERIAL_PATH = process.env.PRINTER_SERIAL_PATH || "/dev/ttyUSB0"; // or /dev/ttyACM0
const BAUD_RATE = 115200;
const COMMAND_TIMEOUT = 800; // ms to wait for response

let port: any = null;
let parser: any = null;
let commandQueue: Array<() => Promise<void>> = [];
let isProcessing = false;

let SerialPort: any = null;
let ReadlineParser: any = null;
let initialized = false;
let isMockMode = false;

/**
 * Initialize serial connection to printer
 */
export async function initSerialConnection(): Promise<void> {
  return new Promise(async (resolve, reject) => {
    try {
      // Load SerialPort on demand
      if (!initialized) {
        try {
          const classes = await getSerialPortClasses();
          SerialPort = classes.SerialPort;
          ReadlineParser = classes.ReadlineParser;
          isMockMode = classes.mockMode;
          initialized = true;
        } catch (err: any) {
          // Fall back to mock mode on error
          isMockMode = true;
          initialized = true;
          console.log("Using MOCK MODE - commands won't affect real printer");
        }
      }

      if (isMockMode) {
        console.log("Mock mode: Printer connection simulated");
        return resolve();
      }

      // Check if already connected
      if (port && port.isOpen) {
        console.log("Printer already connected");
        return resolve();
      }

      port = new SerialPort({
        path: SERIAL_PATH,
        baudRate: BAUD_RATE,
        autoOpen: false,
      });

      parser = port.pipe(new ReadlineParser({ delimiter: "\n" }));

      port.on("error", (err: any) => {
        console.error("Serial port error:", err);
        reject(err);
      });

      port.open((err: any) => {
        if (err) {
          console.error("Failed to open serial port:", err);
          reject(err);
        } else {
          console.log(`Printer connected on ${SERIAL_PATH} at ${BAUD_RATE} baud`);
          resolve();
        }
      });
    } catch (err) {
      reject(err);
    }
  });
}

/**
 * Send G-code command to printer and wait for response
 * @param cmd G-code command (e.g., "G28", "M104 S200")
 * @returns Array of response lines from printer
 */
export function sendGcode(cmd: string): Promise<string[]> {
  return new Promise((resolve, reject) => {
    // In mock mode, return simulated responses
    if (isMockMode) {
      const mockResponses: { [key: string]: string[] } = {
        "M105": ["ok T:25.0 /0.0 B:24.5 /0.0"],
        "M114": ["X:100.00 Y:50.00 Z:10.00 E:0.00", "ok"],
        "M115": ["FIRMWARE_NAME:Marlin 2.0.9.7", "FIRMWARE_VERSION:V5.1", "MACHINE_TYPE:3D Printer", "ok"],
        "M119": ["x_min: open", "y_min: open", "z_min: open", "ok"],
        "M31": ["Print time: 0h 0m 45s", "ok"],
        "G28": ["ok"],
        "M104": ["ok"],
        "M109": ["ok"],
        "M140": ["ok"],
        "M190": ["ok"],
        "M106": ["ok"],
        "M107": ["ok"],
        "M17": ["ok"],
        "M18": ["ok"],
        "M83": ["ok"],
        "M82": ["ok"],
      };

      let response = ["ok"];
      for (const [key, val] of Object.entries(mockResponses)) {
        if (cmd.startsWith(key)) {
          response = val;
          break;
        }
      }

      setTimeout(() => resolve(response), 50);
      return;
    }

    if (!port || !port.isOpen || !parser) {
      return reject(new Error("Printer not connected"));
    }

    const lines: string[] = [];
    let timeout: NodeJS.Timeout;

    const cleanup = () => {
      if (timeout) clearTimeout(timeout);
      parser?.removeListener("data", onData);
    };

    // Timeout handler
    timeout = setTimeout(() => {
      cleanup();
      resolve(lines);
    }, COMMAND_TIMEOUT);

    // Data handler
    function onData(data: string) {
      const line = data.trim();
      if (line) {
        lines.push(line);
      }

      if (line.toLowerCase().startsWith("ok")) {
        cleanup();
        resolve(lines);
      }
    }

    parser.on("data", onData);

    // Send command
    port.write(cmd + "\n", (err: any) => {
      if (err) {
        cleanup();
        reject(err);
      }
    });
  });
}

/**
 * Process command queue sequentially to avoid collisions
 */
async function processQueue() {
  if (isProcessing || commandQueue.length === 0) return;

  isProcessing = true;

  while (commandQueue.length > 0) {
    const command = commandQueue.shift();
    if (command) {
      try {
        await command();
      } catch (err) {
        console.error("Command queue error:", err);
      }
    }
  }

  isProcessing = false;
}

/**
 * Queue a G-code command to prevent collision
 * @param cmd G-code command
 * @returns Promise resolving to response lines
 */
export function queueGcode(cmd: string): Promise<string[]> {
  return new Promise((resolve, reject) => {
    commandQueue.push(async () => {
      try {
        const result = await sendGcode(cmd);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    });

    processQueue();
  });
}

/**
 * Check if printer is connected
 */
export function isPrinterConnected(): boolean {
  if (isMockMode) return true;
  return port !== null && port.isOpen;
}

/**
 * Close serial connection
 */
export function closeConnection(): Promise<void> {
  return new Promise((resolve) => {
    if (port && port.isOpen) {
      port.close(() => {
        console.log("Printer connection closed");
        port = null;
        parser = null;
        resolve();
      });
    } else {
      resolve();
    }
  });
}

/**
 * Get connection status and info
 */
export async function getConnectionInfo() {
  // Ensure initialized
  if (!initialized) {
    await initSerialConnection();
  }
  
  return {
    connected: isPrinterConnected(),
    path: SERIAL_PATH,
    baudRate: BAUD_RATE,
    mockMode: isMockMode,
    message: isMockMode 
      ? "MOCK MODE: API is working but printer is not actually connected. For real hardware, ensure serialport native bindings are built." 
      : "Connected to real printer",
  };
}

// Auto-connect on module load (optional - can be triggered by first API call instead)
// Uncomment if you want automatic connection on server start
// initSerialConnection().catch((err) => {
//   console.error("Failed to auto-connect to printer:", err);
// });
